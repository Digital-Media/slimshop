<?php
namespace DBAccess;

use Elasticsearch\ClientBuilder;
use Fhooe\NormForm\Core\AbstractNormForm;
use Fhooe\NormForm\Parameter\GenericParameter;
use Fhooe\NormForm\Parameter\PostParameter;
use Fhooe\NormForm\View\View;
use Utilities\Utilities;
use Utilities\LogWriter;
use PDO;

/**
 * Class ESearchDEmo implements a demo page for the class AbstractNormForm combined with the class DBAccess
 * of OnlineShop and how to use ElasticSearch for searching.
 *
 * This class is initialized by htdocs/esearchdemo.php, is derived from the class AbstractNormForm and uses TWIG templates.
 * Additionally the class DBAccess is used for database access and ElasticSearch for searching.
 * DBAccess replaces the class FileAccess of the project PHPintro.
 * Due to the usage of PDO Prepared Statements no further steps are necessary to avoid SQL Injection in this use case.
 * XSS is prevented by the TWIG template engine, that escapes variables sent to a template automatically.
 *
 * This page lists the content of onlineshop.product and of ES indizes to demonstrate different search option
 * of MariaDB and Elasticsearch. For index definitions @see src/onlineshop.sql and src/ESCreateIndizes.sh
 *
 * Class ESearchDemo is final, because it makes no sense to derive a class from it.
 *
 * @author  Martin Harrer <martin.harrer@fh-hagenberg.at>
 * @package onlineshop
 * @version 2018
 */
final class ESearchDemo extends AbstractNormForm
{
    /**
     * Constant for a HTML attribute in <input name='ptype' id='ptype' ... >, <label for='ptype' ... >
     * --> $_POST[self::PTYPE]
     */
    const COPY_TO = 'copy_to';

    /**
     * Constant for a HTML attribute
     */
    const LIKE = 'like';

    /**
     * Constant for a HTML attribute
     */
    const MATCH = 'match';

    /**
     * Constant for a HTML attribute
     */
    const NO_CURSOR = 'no_cursor';

    /**
     * Constant for a HTML attribute
     */
    const PAGING = 'paging';

    /**
     * @var string $dbAccess  Database handler for access to database
     */
    private $dbAccess;

    /**
     * @var string $esClient  Client to access ElasticSearch
     */
    private $esClient;

    /**
     * ESearchDemo Constructor.
     *
     * Calls constructor of class AbstractNormForm.
     * Creates a database handler for the database connection.
     * Provides Client for ElasticSearch
     * The assigned constants can be found in src/defines.inc.php
     *
     * @param View $defaultView Holds the initial @View object used for displaying the form.
     *
     * @throws DatabaseException is thrown by all methods of $this->dbAccess and not treated here.
     *         The exception is treated in the try-catch block of the php script, that initializes this class.
     */
    public function __construct(View $defaultView)
    {
        parent::__construct($defaultView);
        $this->logWriter = LogWriter::getInstance();
        $this->dbAccess = new DBAccess(DSN, DB_USER, DB_PWD, DB_NAMES, DB_COLLATION);
        $this->esClient = ClientBuilder::create()
            ->setSerializer('\Elasticsearch\Serializers\SmartSerializer')
            ->build();
        //$this->esClient = ClientBuilder::create()->build(); // SmartSerializer is the default
    }

    /**
     * Validates the user input
     *
     * No Validation necessary for search fields
     *
     * @return bool true, if $errorMessages is empty, else false
     */
    protected function isValid(): bool
    {
        $this->currentView->setParameter(new GenericParameter("errorMessages", $this->errorMessages));
        return (count($this->errorMessages) === 0);
    }

    /**
     * Process the user input, sent with a POST request
     *
     * Serveral search use cases are implemented.
     * Entries in onlineshop.product of MariaDB and in the indices of Elasticsearch are connected with equal ID entries.
     * The IDs for ElasticSearch are set explicitly and NOT autogenerated. No separate id field is used in ElasticSearch.
     *
     * @throws DatabaseException is thrown by all methods of $this->dbAccess and not treated here.
     *         The exception is treated in the try-catch block of the php script, that initializes this class.
     */
    protected function business(): void
    {
        // No (SQL-)Injection possible, if search is done like in this example
        // TWIG prevents XSS
        // Show all entries in ElasticSearch and MariaDB
        if (isset($_POST['all'])) {
            $result = $this->showAllEntries();
            $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillPageArrayAllEntries($result)));
            var_dump($result['hits']['hits']);
        }
        // SQL LIKE is compared with a search, that doesn't use a word decompounder for german (ES-Index: product)
        // Search terms for testing (M found by MariaDB, ES found by Elasticsearch):
        // "grund" (M), "haus" (M), "passivhaus" (M, ES), "almgrundstück" (M, ES) "haus alm" (), "almgrundstuck" (M)
        // "ideal" (M because all fields are used for LIKE, but ES uses only product_name, though index is on all fields)
        if (isset($_POST[self::LIKE])) {
            $search = $_POST[self::LIKE];
            $result = $this->doElasticSearchNoCompound($search);
            $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillPageArrayLIKE($search)));
            var_dump($result['hits']['hits']);
        }
        // A match query of ES is compared with SQL match against for the field product_name only
        // An ES index supports querying parts of the index. MariaDB does not.
        // Additionally a word decompounder is used for ES. For SQL MATCH AGAINST.
        // Search terms for testing (M found by MariaDB, ES found by Elasticsearch):
        // "grund" (ES), "haus" (ES), "passivhaus" (M, ES), "almgrundstück" (M, ES) "haus alm" (), "almgrundstuck" (M, ES)
        // "ideal" ()
        if (isset($_POST[self::MATCH])) {
            $search = $_POST[self::MATCH];
            $result = $this->doElasticSearchMatchProductName($search);
            var_dump($result['hits']['hits']);
            $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillPageArrayMatchProductName($search)));
        }
        // ES supports a copy_to clause to provide a field, that contains all search items.
        // Is compared with SQL match against for all indexed fields.
        // Both searches use different algorithms for calculating relevance.
        // Search terms for testing (M found by MariaDB, ES found by Elasticsearch):
        // "grund" (ES), "haus" (M, ES), "passivhaus" (M, ES), "almgrundstück" (M, ES) "haus alm" (ES), "almgrundstuck" (M, ES)
        // "ideal" (M, ES)
        if (isset($_POST[self::COPY_TO])) {
            $search = $_POST[self::COPY_TO];
            $result = $this->doElasticSearchCopyTo($search);
            var_dump($result['hits']['hits']);
            $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillPageArrayCopyTo($search)));
        }
        // IDs found with ES are used for querying MariaDB.
        // You need to loop over all IDs to build the SQL query either using an IN clause or UNION
        // Search terms for testing. No Search in MariaDB.
        // "grund", "haus", "passivhaus", "almgrundstück", "haus alm", "almgrundstuck", "ideal"
        if (isset($_POST[self::NO_CURSOR])) {
            $search = $_POST[self::NO_CURSOR];
            $result = $this->doElasticSearchCopyTo($search);
            var_dump($result['hits']['hits']);
            $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillPageArrayNoCursor()));
        }
        // A way out of this is using paging for ES and querying a fixed sample of entries in SQL
        // Not very flexible, but easy to implement.
        // Search terms for testing. No Search in MariaDB.
        // "grund", "haus", "passivhaus", "almgrundstück", "haus alm", "almgrundstuck", "ideal"
        if (isset($_POST[self::PAGING])) {
            $search = $_POST[self::PAGING];
            $result = $this->doElasticSearchPaging($search);
            if (count($result['hits']['hits']) !== 0) {
                $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillPageArrayPaging($result)));
                //var_dump($result['hits']['hits']);
                // Debugging without echo, print_r, var_dump
                $this->logWriter->logDebug($result['hits']['hits']);
            }
        }
    }

    /**
     * Show all enries in ES index
     *
     * @return $result Array with all entries of index product
     */
    private function showAllEntries(): array
    {
        $params = [
            "scroll" => "30s",
            "size" => 50,
            "index" => "product",
            "body" => [
                "query" => [
                    "match_all" => new \stdClass()
                ]
            ]
        ];
        $result = $this->esClient->search($params);
        return $result;
    }

    /**
     * Returns an array to display all entries of onlineshop.product on the current page.
     *
     * @param  array $result Result of search in ElasticSearch
     * @return array $result Result set of database query.
     *
     * @throws \DBAccess\DatabaseException
     */
    private function fillPageArrayAllEntries(array $result): array
    {
        $query = <<<SQL
                 SELECT idproduct, product_name, price
                 FROM product
SQL;

        $this->dbAccess->prepareQuery($query, true);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }

    /**
     * ES Index product doesn't use a word decompounder
     *
     * @param string $search Search term sent by user
     *
     * @return array $result Entries in index product matching $search
     */
    private function doElasticSearchNoCompound(string $search): array
    {
        $params = [
            "index" => "product",
            "type" => "_doc",
            "body" => [
                "query" => [
                    "match" => [
                        "product_name" => $search
                    ]
                ]
            ]
        ];
        var_dump($params['body']);
        $result = $this->esClient->search($params);
        return $result;
    }

    /**
     * Returns an array to display all entries of onlineshop.product on the current page.
     *
     * @param  string $search Search term sent by user
     * @return array $result Result set of database query using LIKE for matching.
     *
     * @throws \DBAccess\DatabaseException
     */
    private function fillPageArrayLIKE(string $search): array
    {
        $query = <<<SQL
                 SELECT idproduct, product_name, price
                 FROM product
                 WHERE product_name LIKE :search
                 OR  short_description LIKE :search
                 OR  long_description LIKE :search
SQL;

        $this->dbAccess->prepareQuery($query, true);
        $this->dbAccess->bindValueByType(':search', "%$search%", PDO::PARAM_STR);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }

    /**
     * ES Index product_hyphen_decompounder uses a word decompounder for german
     *
     * Searchterms for testing:
     *
     * @param string $search Search term sent by user
     *
     * @return array $result Entries in index product_hyphen_decompounder.product_name matching $search
     */
    private function doElasticSearchMatchProductName(string $search): array
    {
        $params = [
            "index" => "product",
            "type" => "_doc",
            "body" => [
                "query" => [
                    "match" => [
                        "product_name" => $search
                    ]
                ]
            ]
        ];
        var_dump($params['body']);
        $result = $this->esClient->search($params);
        return $result;
    }

    /**
     * Returns an array to display all entries of onlineshop.product on the current page.
     * This query uses FULLTEXT index on product_name only.
     * FULLTEXT Indizes in MariaDB don't use a word decompounder.
     *
     * @param  string $search Search term sent by user
     * @return array $result Result set of database query using MATCH AGAINST for the product_name column only.
     *
     * @throws \DBAccess\DatabaseException
     */
    private function fillPageArrayMatchProductName(string $search): array
    {
        $query = <<<SQL
                 SELECT idproduct, product_name, price
                 FROM product
                 WHERE match (product_name) against ('$search');
SQL;
        $this->dbAccess->prepareQuery($query, true);
        $this->dbAccess->bindValueByType(':id1', $search, PDO::PARAM_STR);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }

    /**
     * copy_to provides a field, where all search terms of all fields are gathered.
     * Additionally a word decompounder is used in the ES index product_hyphen_deompounder.
     *
     * @param  string $search Search term sent by user
     * @return array $result Result set of ES search against all fields via copy_to field search.
     */
    private function doElasticSearchCopyTo(string $search): array
    {
        $json = '{
             "query" : {
                  "match" : {
                      "search" : "' . $search . '"
                  }
             }
        }';
        $params = [
            "index" => "product",
            "type" => "_doc",
            "body" => $json
        ];
        var_dump($params['body']);
        $result = $this->esClient->search($params);
        return $result;
    }

    /**
     * Returns an array to display all entries of onlineshop.product that match a search item against the
     * columns product_name, short_description and long_description. This is provided by an additional FULLTEXT index
     * on onlineshop.product.
     *
     * @param  array $result Result of search in ElasticSearch
     * @return array $result Result set of database query.
     *
     * @throws \DBAccess\DatabaseException
     */
    private function fillPageArrayCopyTo(string $search): array
    {
        $query = <<<SQL
                         SELECT idproduct, product_name, price
                         FROM product
                         WHERE match (product_name, short_description, long_description) against ('$search');
SQL;
        $this->dbAccess->prepareQuery($query, true);
        $this->dbAccess->bindValueByType(':search', $search, PDO::PARAM_STR);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }

    /**
     * Returns an array to display all entries of onlineshop.product on the current page using an IN clause or
     * UNION. If want to refer to the IDs sent by ES, you have to loop over all ES results an build the queries
     * dynamically.
     *
     * @param  array $result Result of search in ElasticSearch
     * @return array $result Result set of database query.
     *
     * @throws \DBAccess\DatabaseException
     */
    private function fillPageArrayNoCursor(): array
    {
        $id[1]= 1;
        $id[2]= 2;
        $id[3]= 3;
        $id[4]= 4;
        $id[5]= 5;
        $query = <<<SQL
                 SELECT idproduct, product_name, price
                 FROM product
                 WHERE idproduct in (:id1, :id2, :id3, :id4, :id5);
SQL;
        /*
        $query = <<<SQL
                SELECT idproduct, product_name, price
                FROM product
                WHERE idproduct = :id1
                UNION
                SELECT idproduct, product_name, price
                FROM product
                WHERE idproduct = :id2
                UNION
                SELECT idproduct, product_name, price
                FROM product
                WHERE idproduct = :id3
                UNION
                SELECT idproduct, product_name, price
                FROM product
                WHERE idproduct = :id4
                UNION
                SELECT idproduct, product_name, price
                FROM product
                WHERE idproduct = :id5;
        SQL;
        //*/
        $this->dbAccess->prepareQuery($query, true);
        $this->dbAccess->bindValueByType(':id1', $id[1], PDO::PARAM_INT);
        $this->dbAccess->bindValueByType(':id2', $id[2], PDO::PARAM_INT);
        $this->dbAccess->bindValueByType(':id3', $id[3], PDO::PARAM_INT);
        $this->dbAccess->bindValueByType(':id4', $id[4], PDO::PARAM_INT);
        $this->dbAccess->bindValueByType(':id5', $id[5], PDO::PARAM_INT);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }

    /**
     * Returning the results of an ES search using from and size for paging. Only the first page is queried in this case.
     * For real paging you have to calculate and remember the from value for each page.
     *
     * @param  string $search Search term sent by user
     * @return array $result Result set of ES search against all fields via copy_to field search.
     */
    private function doElasticSearchPaging(string $search): array
    {
        $json = '{
          "query": {
            "match" : {
              "search" : {
                "query" : "' . $search  . '"
              }
            }
          }
        }';
        $params = [
            "index" => "product",
            "type" => "_doc",
            "from" => 0,
            "size" => 2,
            "body" => $json
        ];
        //var_dump($params['body']);
        // Debugging without echo, print_r, var_dump
        $this->logWriter->logInfo($params['body']);
        $result = $this->esClient->search($params);
        return $result;
    }

    /**
     * Uses only an ID count of size delivered by ES search for the IN clause. @see doElasticSearchPaging()
     *
     * @param  array $result Result of search in ElasticSearch
     * @return array $result Result set of database query with IN clause.
     *
     * @throws \DBAccess\DatabaseException
     */
    private function fillPageArrayPaging(array $result): array
    {

        $id[1]= intval($result['hits']['hits'][0]['_id']);
        $id[2]= isset($result['hits']['hits'][1]['_id']) ? intval($result['hits']['hits'][1]['_id']) : 0;
        $query = <<<SQL
                SELECT idproduct, product_name, price
                FROM product
                WHERE idproduct in (:id1, :id2)
SQL;

        $this->dbAccess->prepareQuery($query, true);
        $this->dbAccess->bindValueByType(':id1', $id[1], PDO::PARAM_INT);
        $this->dbAccess->bindValueByType(':id2', $id[2], PDO::PARAM_INT);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }
}
